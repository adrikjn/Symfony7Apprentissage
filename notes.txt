****************************************************************************

Installer le projet et les préréquis : 

composer create-project symfony/skeleton:"7.0.*" my_project_directory
cd my_project_directory
composer require webapp

Démarrer le serveur interne de php
php -S localhost:8000 -t public

****************************************************************************

Créer un controller (Fichier twig & Controller généré): 
php bin/console make:controller NomDuController

On met ensuite la route qui pointe sur le / en changeant le name si on le souhaite
Dans le base.html.twig on met le code qui sera présent sur toute les pages (exemple header/footer - Utilisation de bootstrap (cdn).. JS/CSS..)
Le controller grâce au render permettra de gérer la route on peut inclure des variables afin de rendre le site dynamique et nous pouvons les afficher à l'aide de {{  }}
Pour gérer les routes nous allons utiliser path() qui va inclure le nom de la route, d'autre paramètres peuvent être inclus comme l'id le slug etc.. dans le path

****************************************************************************

Création base de données & entités

Dans le fichier .env on va utiliser mysql on commente donc l'autre ligne et on va décommenter mysql.
On va changer les informations comme ceci : DATABASE_URL="mysql://root@127.0.0.1:3306/symfony7apprentissage"
Puis nous allons faire la commande :

php bin/console d:d:c pour créer la base de donnée de notre projet

On peut par la suite créer les entités a l'aide de la commande : 

php bin/console make:entity  - entré
Choisir le nom de l'entité
Symfony UX Turbo = Enter sur non
nom de la propriété et son type (Exemple : title - string / createdAt - dateImmutable)
field lenght est le nb maximal de caractère stockable pour le champs
Nullable ? Non car chaque recette doit avoir un nom

SUCCESS

Deux fichiers on été créer dans le dossier Entité et Repository
L'entité contient chacun des propriétés et ses différents getter et setter que l'on utilisera.
Le repositery contiendra toute les méthodes afin de communiquer avec la BDD pour récupérer des informations par exemple.


Nous pouvons faire la commande ci dessous pour créer le fichier de migration (Requête SQL permettant de créer les tables):

php bin/console make:migration 

Puis on exécuter le fichier de migration dans la BDD à l'aide de la commande :

php bin/console d:m:m
Yes

SUCCESS

Pour récupérer des informations depuis la BDD nous allons utliser le repositery (exemple :  $recipes = $repository->findAll();) dans notre controller tout en envoyant la variable dans le render et nous pouvons par la suite afficher les recettes en faisant une boucle dans le fichie twig de cette manière : 

    {% for recipe in recipes %}
		<li><a href="{{ path('recipe.show', {id: recipe.id, slug: recipe.slug})}}">{{ recipe.title }}</a></li>
	{% endfor %}

Nous pouvons aussi construire des requêtes plus compliqué dans le Repository à l'aide du queryBuilder si l'on veut es informations plus difficile a obtenir comme :
Duration - de 10 minutes seulement

****************************************************************************

Créer un formulaire pour une entité :

php bin/console make:form
NomType
Bound : Yes

Automatiquement un fichier RecipeType dans le dossierform va être créer contenant les champs de l'entités

Afin d'appliquer le style de bootstrap sur les formulaires il faut se rendre dans config puis packages puis twig.yaml et placer :
twig:
    file_name_pattern: '*.twig'
    form_themes: ['bootstrap_5_layout.html.twig']

Dans le controller il faudra construire une requête permettant de traiter le formulaire a l'aide du handleRequest puis flush..
Le edit va récupérer dans le form les informations de la recette sous forme de formulaire et il faudra ainsi faire quelque modifications dans le recipetype ou il faudra retirer les données dynamiques (createdAt par exemple.) On peut rajouter des label a partir du recipe type des buttons etc mais je préfère faire ceci a partir du fichier twig edit.
Dans le fichier twig il faudra faire un form_start(nom de la variable) puis lister tout les champs que l'on souhaite mettre de la manière : {{form_row(form.title)}} dans le formulaire puis un button pour le formulaire puis refermer avec un form_end(nom de la variable). Ainsi l'edit marchera convenablement.


Affcher un message flash suite au Edit qui sera effacé lorsqu'on refresh la page.

Message flash : Dans le controller avant le redirect on place par exemple : 
         $this->addFlash('success', 'La recette a bien été modifiée');
on include dans le body.html.twig	:	{% include "partials/flash.html.twig" %}
On créer un dossier partials et un ficher flash.html.twig on fait une boucle selon le type : 
{% for type, messages in app.flashes %}
    <div class="alert alert-{{ type }}">
        {{  messages | join('. ')}}
    </div>
{% endfor %}

Pour le create ça marche presque de la même manièe cependant on doit set les valeurs dans la fonction relatif au datetime et on doit créer un objet vide afin de rentrer de nouvelles données ($recipe = new Recipe();) On persist on flush et les données sont envoyé en BDD

Pour autoriser le delete on va dans config puis packages puis framework.yaml
on ajoute la dernirèe ligne en dessous de fragment
    #esi: true
    #fragments: true
    http_method_override: true

On doit mettre la methode delete dans la route et dans le fichier twig nous devons faire ceci pour simuler un delete

                <form action="{{path('recipe.delete', {id: recipe.id})}}" method="post">
				<input type="hidden" name="_method" value="DELETE">
					<button type="submit" class="btn btn-danger btn-sm" >Supprimer</button>
				</form>

On peut aussi créer des eventlistener par exemple si slug vide il prend le nom du title MËME SI le champ n'est pas NULLABLE !!

****************************************************************************

Valider les données 

On peut le faire dans le fichier type ou dans l'entité directement
Sequentially permet d'afficher les erreurs 1 par 1 (meilleur pour le STYLE) afin d'éviter le spam on corrige d'abord une erreure et la second peut apparaitre par la suite.
->add('slug', TextType::class, [
                'required' => false,
            ])

Pour faire des banword :
php bin/console make:validator /  BanWordValidator
Il faudra placer avant la propriété de l'entité ceci : #[BanWord()] et faire les modifications des deux fichiers (regarder)